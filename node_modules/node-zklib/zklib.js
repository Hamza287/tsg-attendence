const ZKLibTCP = require('./zklibtcp');
const ZKLibUDP = require('./zklibudp');

const { ZKError , ERROR_TYPES } = require('./zkerror');

class ZKLib {
    constructor(ip, port, timeout , inport){
        this.connectionType = null;

        this.zklibTcp = new ZKLibTCP(ip,port,timeout); 
        this.zklibUdp = new ZKLibUDP(ip,port,timeout , inport); 
        this.interval = null; 
        this.timer = null;
        this.isBusy = false;
        this.ip = ip;
    }

    async functionWrapper (tcpCallback, udpCallback , command ){
        switch(this.connectionType){
            case 'tcp':
                if(this.zklibTcp.socket){
                    try{
                        return await tcpCallback();
                    }catch(err){
                        return Promise.reject(new ZKError(err, `[TCP] ${command}`, this.ip));
                    }
                }else{
                    return Promise.reject(new ZKError(new Error(`Socket isn't connected !`), `[TCP]`, this.ip));
                }
            case 'udp':
                if(this.zklibUdp.socket){
                    try{
                        return await udpCallback();
                    }catch(err){
                        return Promise.reject(new ZKError(err, `[UDP] ${command}`, this.ip));
                    }    
                }else{
                    return Promise.reject(new ZKError(new Error(`Socket isn't connected !`), `[UDP]`, this.ip));
                }
            default:
                return Promise.reject(new ZKError(new Error(`Socket isn't connected !`), '', this.ip));
        }
    }

    async createSocket(cbErr, cbClose){
        try{
            if(!this.zklibTcp.socket){
                await this.zklibTcp.createSocket(cbErr,cbClose);
                await this.zklibTcp.connect();
                console.log('ok tcp');
            }      
            this.connectionType = 'tcp';
        }catch(err){
            try { await this.zklibTcp.disconnect(); } catch {}
            if(err.code !== ERROR_TYPES.ECONNREFUSED){
                return Promise.reject(new ZKError(err, 'TCP CONNECT' , this.ip));
            }
            try {
                if(!this.zklibUdp.socket){
                    await this.zklibUdp.createSocket(cbErr, cbClose);
                    await this.zklibUdp.connect();
                }   
                console.log('ok udp');
                this.connectionType = 'udp';
            }catch(err){
                if(err.code !== 'EADDRINUSE'){
                    this.connectionType = null;
                    try{
                        await this.zklibUdp.disconnect();
                        this.zklibUdp.socket = null;
                        this.zklibTcp.socket = null;
                    }catch{}
                    return Promise.reject(new ZKError(err, 'UDP CONNECT' , this.ip));
                }else{
                    this.connectionType = 'udp';
                }
            }
        }
    }

    async getUsers(){
        return this.functionWrapper(
            ()=> this.zklibTcp.getUsers(),
            ()=> this.zklibUdp.getUsers(),
            'GET_USERS'
        );
    }

    async getAttendances(cb){
        return this.functionWrapper(
            ()=> this.zklibTcp.getAttendances(cb),
            ()=> this.zklibUdp.getAttendances(cb),
            'GET_ATTENDANCES'
        );
    }

    async getRealTimeLogs(cb){
        return this.functionWrapper(
            ()=> this.zklibTcp.getRealTimeLogs(cb),
            ()=> this.zklibUdp.getRealTimeLogs(cb),
            'REALTIME_LOGS'
        );
    }

    async disconnect(){
        return this.functionWrapper(
            ()=> this.zklibTcp.disconnect(),
            ()=> this.zklibUdp.disconnect(),
            'DISCONNECT'
        );
    }

    async freeData(){
        return this.functionWrapper(
            ()=> this.zklibTcp.freeData(),
            ()=> this.zklibUdp.freeData(),
            'FREE_DATA'
        );
    }

    async disableDevice(){
        return this.functionWrapper(
            ()=> this.zklibTcp.disableDevice(),
            ()=> this.zklibUdp.disableDevice(),
            'DISABLE_DEVICE'
        );
    }

    async enableDevice(){
        return this.functionWrapper(
            ()=> this.zklibTcp.enableDevice(),
            ()=> this.zklibUdp.enableDevice(),
            'ENABLE_DEVICE'
        );
    }

    async getInfo(){
        return this.functionWrapper(
            ()=> this.zklibTcp.getInfo(),
            ()=> this.zklibUdp.getInfo(),
            'GET_INFO'
        );
    }

    async getSocketStatus(){
        return this.functionWrapper(
            ()=> this.zklibTcp.getSocketStatus(),
            ()=> this.zklibUdp.getSocketStatus(),
            'SOCKET_STATUS'
        );
    }

    async clearAttendanceLog(){
        return this.functionWrapper(
            ()=> this.zklibTcp.clearAttendanceLog(),
            ()=> this.zklibUdp.clearAttendanceLog(),
            'CLEAR_ATTLOG'
        );
    }

    async executeCmd(command, data=''){
        return this.functionWrapper(
            ()=> this.zklibTcp.executeCmd(command, data),
            ()=> this.zklibUdp.executeCmd(command , data),
            'EXEC_CMD'
        );
    }

    // âœ… Added missing ones
    async getTime(){
        return this.functionWrapper(
            ()=> this.zklibTcp.getTime(),
            ()=> this.zklibUdp.getTime(),
            'GET_TIME'
        );
    }

    async setTime(date = new Date()){
        return this.functionWrapper(
            ()=> this.zklibTcp.setTime(date),
            ()=> this.zklibUdp.setTime(date),
            'SET_TIME'
        );
    }

    setIntervalSchedule(cb , timer){
        this.interval = setInterval(cb, timer);
    }

    setTimerSchedule(cb, timer){
        this.timer = setTimeout(cb,timer);
    }
}

module.exports = ZKLib;
