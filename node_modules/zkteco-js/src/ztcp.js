/**
 *
 * Author: coding-libs
 * Date: 2024-07-01
 */

const net = require('net')
const { MAX_CHUNK, COMMANDS, REQUEST_DATA } = require('./helper/command')
const timeParser = require('./helper/time')

const {
  createTCPHeader,
  exportErrorMessage,
  removeTcpHeader,
  decodeUserData72,
  decodeRecordData40,
  decodeRecordRealTimeLog52,
  checkNotEventTCP,
  decodeTCPHeader,
} = require('./helper/utils')

const { log } = require('./logs/log')

// ✅ Safe buffer reader — prevents ERR_OUT_OF_RANGE
function safeRead(buf, method, offset, len, fallback = null) {
  try {
    if (!Buffer.isBuffer(buf)) return fallback
    if (buf.length < offset + len) return fallback
    return buf[method](offset)
  } catch (e) {
    log('warn', `safeRead failed: ${method}@${offset}, len=${len}, bufLen=${buf?.length}`)
    return fallback
  }
}

class ZTCP {
  constructor(ip, port, timeout) {
    this.ip = ip
    this.port = port
    this.timeout = timeout
    this.sessionId = null
    this.replyId = 0
    this.socket = null
  }

  createSocket(cbError, cbClose) {
    return new Promise((resolve, reject) => {
      this.socket = new net.Socket()

      this.socket.once('error', (err) => {
        this.socket = null
        reject(err)
        if (typeof cbError === 'function') cbError(err)
      })

      this.socket.once('connect', () => {
        resolve(this.socket)
      })

      this.socket.once('close', () => {
        this.socket = null
        if (typeof cbClose === 'function') cbClose('tcp')
      })

      if (this.timeout) {
        this.socket.setTimeout(this.timeout)
      }

      this.socket.connect(this.port, this.ip)
    })
  }

  async connect() {
    try {
      const reply = await this.executeCmd(COMMANDS.CMD_CONNECT, '')
      if (reply) {
        return true
      } else {
        throw new Error('NO_REPLY_ON_CMD_CONNECT')
      }
    } catch (err) {
      console.error('Failed to connect:', err?.message || err)
      return false
    }
  }

  async closeSocket() {
    return new Promise((resolve, reject) => {
      if (!this.socket) return resolve(true)
      this.socket.removeAllListeners('data')

      const timer = setTimeout(() => {
        this.socket.destroy()
        resolve(true)
      }, 2000)

      this.socket.end(() => {
        clearTimeout(timer)
        resolve(true)
      })

      this.socket.once('error', (err) => {
        clearTimeout(timer)
        reject(err)
      })
    })
  }

  writeMessage(msg, connect) {
    return new Promise((resolve, reject) => {
      if (!this.socket) {
        return reject(new Error('Socket is not initialized'))
      }

      let timer = null

      const onData = (data) => {
        if (this.socket) {
          this.socket.removeListener('data', onData)
        }
        clearTimeout(timer)
        resolve(data)
      }

      this.socket.once('data', onData)

      this.socket.write(msg, null, (err) => {
        if (err) {
          if (this.socket) {
            this.socket.removeListener('data', onData)
          }
          return reject(err)
        }

        if (this.timeout) {
          timer = setTimeout(() => {
            if (this.socket) {
              this.socket.removeListener('data', onData)
            }
            reject(new Error('TIMEOUT_ON_WRITING_MESSAGE'))
          }, connect ? 2000 : this.timeout)
        }
      })
    })
  }

  requestData(msg) {
    return new Promise((resolve, reject) => {
      let timer = null
      let replyBuffer = Buffer.from([])

      const internalCallback = (data) => {
        if (this.socket) {
          this.socket.removeListener('data', handleOnData)
        }
        if (timer) clearTimeout(timer)
        resolve(data)
      }

      const handleOnData = (data) => {
        replyBuffer = Buffer.concat([replyBuffer, data])

        if (checkNotEventTCP(data)) return

        const header = decodeTCPHeader(replyBuffer.subarray(0, 16))

        if (header.commandId === COMMANDS.CMD_DATA) {
          timer = setTimeout(() => {
            internalCallback(replyBuffer)
          }, 1000)
        } else {
          timer = setTimeout(() => {
            if (this.socket) {
              this.socket.removeListener('data', handleOnData)
            }
            reject(new Error('TIMEOUT_ON_RECEIVING_REQUEST_DATA'))
          }, this.timeout)

          const packetLength = safeRead(data, 'readUIntLE', 4, 2, 0)
          if (packetLength > 8) {
            internalCallback(data)
          }
        }
      }

      if (this.socket) {
        this.socket.on('data', handleOnData)

        this.socket.write(msg, null, (err) => {
          if (err) {
            if (this.socket) {
              this.socket.removeListener('data', handleOnData)
            }
            return reject(err)
          }

          timer = setTimeout(() => {
            if (this.socket) {
              this.socket.removeListener('data', handleOnData)
            }
            reject(new Error('TIMEOUT_IN_RECEIVING_RESPONSE_AFTER_REQUESTING_DATA'))
          }, this.timeout)
        })
      } else {
        reject(new Error('SOCKET_NOT_INITIALIZED'))
      }
    }).catch((err) => {
      console.error('Promise Rejected:', err)
      throw err
    })
  }

  async executeCmd(command, data) {
    if (command === COMMANDS.CMD_CONNECT) {
      this.sessionId = 0
      this.replyId = 0
    } else {
      this.replyId++
    }

    const buf = createTCPHeader(command, this.sessionId, this.replyId, data)

    try {
      const reply = await this.writeMessage(buf, command === COMMANDS.CMD_CONNECT || command === COMMANDS.CMD_EXIT)
      const rReply = removeTcpHeader(reply)

      if (command === COMMANDS.CMD_CONNECT && rReply && rReply.length >= 6) {
        this.sessionId = safeRead(rReply, 'readUInt16LE', 4, 2, 0)
      }

      return rReply
    } catch (err) {
      console.error('Error executing command:', err?.message || err)
      return null
    }
  }

  // ✅ Hardened getTime
  async getTime() {
    try {
      const response = await this.executeCmd(COMMANDS.CMD_GET_TIME, '')
      if (!response || !Buffer.isBuffer(response) || response.length < 12) {
        console.warn('[ZTCP] getTime: invalid/short response')
        return null
      }
      const timeValue = safeRead(response, 'readUInt32LE', 8, 4, null)
      return timeValue ? timeParser.decode(timeValue) : null
    } catch (err) {
      console.error('Error getting time:', err.message)
      return null
    }
  }

  async setTime(tm) {
    try {
      const date = tm instanceof Date ? tm : new Date(tm)
      const encodedTime = timeParser.encode(date)
      const commandString = Buffer.alloc(32)
      commandString.writeUInt32LE(encodedTime, 0)
      return await this.executeCmd(COMMANDS.CMD_SET_TIME, commandString)
    } catch (err) {
      console.error('Error setting time:', err.message)
      return null
    }
  }
  /**
   * Read buffered response (users / attendance logs)
   * @param {*} reqData - REQUEST_DATA.GET_USERS or REQUEST_DATA.GET_ATTENDANCE_LOGS
   * @param {*} cb - optional progress callback
   */
  readWithBuffer(reqData, cb = null) {
    return new Promise(async (resolve, reject) => {
      this.replyId++;
      const buf = createTCPHeader(COMMANDS.CMD_DATA_WRRQ, this.sessionId, this.replyId, reqData);
      let reply;

      try {
        reply = await this.requestData(buf);
      } catch (err) {
        return reject(err);
      }

      const header = decodeTCPHeader(reply.subarray(0, 16));
      switch (header.commandId) {
        case COMMANDS.CMD_DATA: {
          return resolve({ data: reply.subarray(16), mode: 8 });
        }
        case COMMANDS.CMD_ACK_OK:
        case COMMANDS.CMD_PREPARE_DATA: {
          const recvData = reply.subarray(16);
          const size = safeRead(recvData, "readUIntLE", 1, 4, 0);

          let remain = size % MAX_CHUNK;
          let numberChunks = Math.floor(size / MAX_CHUNK);
          let totalPackets = numberChunks + (remain > 0 ? 1 : 0);
          let replyData = Buffer.from([]);
          let totalBuffer = Buffer.from([]);
          let realTotalBuffer = Buffer.from([]);

          const timeout = 10000;
          let timer = setTimeout(() => {
            internalCallback(replyData, new Error("TIMEOUT WHEN RECEIVING PACKET"));
          }, timeout);

          const internalCallback = (replyData, err = null) => {
            clearTimeout(timer);
            resolve({ data: replyData, err });
          };

          const handleOnData = (reply) => {
            if (checkNotEventTCP(reply)) return;
            clearTimeout(timer);
            timer = setTimeout(() => {
              internalCallback(replyData, new Error(`TIME OUT !! ${totalPackets} PACKETS REMAIN !`));
            }, timeout);

            totalBuffer = Buffer.concat([totalBuffer, reply]);
            const packetLength = safeRead(totalBuffer, "readUIntLE", 4, 2, 0);
            if (totalBuffer.length >= 8 + packetLength) {
              realTotalBuffer = Buffer.concat([realTotalBuffer, totalBuffer.subarray(16, 8 + packetLength)]);
              totalBuffer = totalBuffer.subarray(8 + packetLength);

              if ((totalPackets > 1 && realTotalBuffer.length === MAX_CHUNK + 8) ||
                  (totalPackets === 1 && realTotalBuffer.length === remain + 8)) {
                replyData = Buffer.concat([replyData, realTotalBuffer.subarray(8)]);
                totalBuffer = Buffer.from([]);
                realTotalBuffer = Buffer.from([]);
                totalPackets -= 1;
                cb && cb(replyData.length, size);
                if (totalPackets <= 0) {
                  internalCallback(replyData);
                }
              }
            }
          };

          this.socket.once("close", () => {
            internalCallback(replyData, new Error("Socket is disconnected unexpectedly"));
          });

          this.socket.on("data", handleOnData);

          for (let i = 0; i <= numberChunks; i++) {
            if (i === numberChunks) {
              this.sendChunkRequest(numberChunks * MAX_CHUNK, remain);
            } else {
              this.sendChunkRequest(i * MAX_CHUNK, MAX_CHUNK);
            }
          }
          break;
        }
        default:
          reject(new Error("ERROR_IN_UNHANDLE_CMD " + exportErrorMessage(header.commandId)));
      }
    });
  }

  async getUsers() {
    try {
      if (this.socket) await this.freeData()
      const data = await this.readWithBuffer(REQUEST_DATA.GET_USERS)
      if (this.socket) await this.freeData()

      if (!data.data || !(data.data instanceof Buffer)) {
        console.warn('[ZTCP] getUsers: invalid response')
        return { data: [] }
      }

      const users = []
      let userData = data.data.subarray(4)
      while (userData.length >= 72) {
        try {
          users.push(decodeUserData72(userData.subarray(0, 72)))
        } catch (e) {
          console.warn('[ZTCP] decodeUserData72 failed:', e.message)
        }
        userData = userData.subarray(72)
      }
      return { data: users }
    } catch (err) {
      console.error('Error getting users:', err.message)
      return { data: [] }
    }
  }

  async getAttendances(callbackInProcess = () => {}) {
    try {
      if (this.socket) await this.freeData()
      const data = await this.readWithBuffer(REQUEST_DATA.GET_ATTENDANCE_LOGS, callbackInProcess)
      if (this.socket) await this.freeData()

      if (!data.data || !(data.data instanceof Buffer)) {
        console.warn('[ZTCP] getAttendances: invalid response')
        return { data: [] }
      }

      const records = []
      let recordData = data.data.subarray(4)
      while (recordData.length >= 40) {
        try {
          records.push({ ...decodeRecordData40(recordData.subarray(0, 40)), ip: this.ip })
        } catch (e) {
          console.warn('[ZTCP] decodeRecordData40 failed:', e.message)
        }
        recordData = recordData.subarray(40)
      }
      return { data: records }
    } catch (err) {
      console.error('Error getting attendance records:', err.message)
      return { data: [] }
    }
  }

  async freeData() {
    try {
      return await this.executeCmd(COMMANDS.CMD_FREE_DATA, '')
    } catch {
      return null
    }
  }

  async getRealTimeLogs(cb = () => {}) {
    this.replyId++
    try {
      const buf = createTCPHeader(COMMANDS.CMD_REG_EVENT, this.sessionId, this.replyId, Buffer.from([0x01, 0x00, 0x00, 0x00]))
      this.socket.write(buf, (err) => {
        if (err) {
          console.error('Error sending realtime request:', err.message)
        }
      })

      if (this.socket.listenerCount('data') === 0) {
        this.socket.on('data', (data) => {
          if (checkNotEventTCP(data)) {
            if (data.length > 16) {
              try {
                cb(decodeRecordRealTimeLog52(data))
              } catch (e) {
                console.warn('[ZTCP] decodeRealTimeLog failed:', e.message)
              }
            }
          }
        })
      }
    } catch (err) {
      console.error('Error getting realtime logs:', err.message)
    }
  }
}

module.exports = ZTCP
